const std = @import("std");

/// Multiplication modulo 2^16 + 1 (IDEA's special multiplication)
/// Inputs are u16, but 0 is treated as 2^16 (65536)
/// Output is u16, where 0 represents 2^16
fn mul(a: u16, b: u16) u16 {
    const long_a: u64 = if (a == 0) 0x10000 else a;
    const long_b: u64 = if (b == 0) 0x10000 else b;
    
    // (a * b) % (2^16 + 1)
    var r: u64 = (long_a * long_b);
    
    // Optimization for modulo 65537:
    // r = (x * y)
    // r % 65537
    // Using the property that 2^16 = -1 mod (2^16 + 1)
    // r = q * 2^16 + rem
    // r = q * (-1) + rem = rem - q
    // This is valid, but let's stick to simple division for correctness first unless it's too slow.
    // u64 division is fast enough for now.
    
    r = r % 0x10001;
    
    return @intCast(if (r == 0x10000) 0 else r);
}

/// Extended Euclidean Algorithm to find modular inverse
/// Returns x such that (a * x) % m == 1
fn mulInv(a: u16) u16 {
    if (a == 0) {
        // 0 corresponds to 2^16. Inverse of 2^16 mod 2^16+1 is ?
        // 2^16 = -1 mod 2^16+1. Inverse of -1 is -1.
        // -1 corresponds to 2^16, which is 0.
        // So mulInv(0) is 0.
        return 0; 
    }
    
    var t: i64 = 0;
    var newt: i64 = 1;
    var r: i64 = 0x10001;
    var newr: i64 = a;

    while (newr != 0) {
        const quotient = @divTrunc(r, newr);
        
        const temp_t = t;
        t = newt;
        newt = temp_t - quotient * newt;
        
        const temp_r = r;
        r = newr;
        newr = temp_r - quotient * newr;
    }

    if (r > 1) return 0; // Not invertible, shouldn't happen for prime modulus
    if (t < 0) t = t + 0x10001;

    return @intCast(if (t == 0x10000) 0 else t);
}

fn addInv(a: u16) u16 {
    return @bitCast(-%@as(i16, @bitCast(a))); // Two's complement negation corresponds to additive inverse mod 2^16
}

pub fn generateSubkeys(key: u128) [52]u16 {
    var subkeys: [52]u16 = undefined;

    // The first 8 subkeys are the key itself
    for (0..8) |i| {
        subkeys[i] = @intCast((key >> @intCast((7 - i) * 16)) & 0xFFFF);
    }

    // Subsequent subkeys are generated by rotating
    var current_key = key;
    for (1..7) |round| { // We need more batches. 52 subkeys / 8 = 6.5 batches.
        // Rotate left by 25 bits
        // key is 128 bits.
        // Left rotate 25: (key << 25) | (key >> (128 - 25))
        const high = current_key >> (128 - 25);
        current_key = (current_key << 25) | high;

        for (0..8) |i| {
            const index = round * 8 + i;
            if (index < 52) {
                subkeys[index] = @intCast((current_key >> @intCast((7 - i) * 16)) & 0xFFFF);
            }
        }
    }
    
    return subkeys;
}

pub fn invertSubkeys(subkeys: [52]u16) [52]u16 {
    var dec_subkeys: [52]u16 = undefined;
    
    // Round 1
    dec_subkeys[0] = mulInv(subkeys[48]);
    dec_subkeys[1] = addInv(subkeys[49]);
    dec_subkeys[2] = addInv(subkeys[50]);
    dec_subkeys[3] = mulInv(subkeys[51]);
    
    dec_subkeys[4] = subkeys[46];
    dec_subkeys[5] = subkeys[47];
    
    // Rounds 2-8
    for (1..8) |r| {
        const i = r * 6;
        const j = (8 - r) * 6; // Index into encryption subkeys
        
        dec_subkeys[i + 0] = mulInv(subkeys[j + 0]);
        dec_subkeys[i + 1] = addInv(subkeys[j + 2]); // Note swap of 2 and 1
        dec_subkeys[i + 2] = addInv(subkeys[j + 1]);
        dec_subkeys[i + 3] = mulInv(subkeys[j + 3]);
        
        dec_subkeys[i + 4] = subkeys[j - 2];
        dec_subkeys[i + 5] = subkeys[j - 1];
    }
    
    // Output transformation (Round 9 - half round)
    dec_subkeys[48] = mulInv(subkeys[0]);
    dec_subkeys[49] = addInv(subkeys[1]); // No swap here?
    // Wait, standard description says:
    // The first 4 subkeys for decryption round 1 are derived from encryption round 9.
    // The last 4 subkeys for decryption round 9 are derived from encryption round 1.
    // The inner subkeys are swapped and inverted.
    
    // Let's re-verify the indices.
    // Enc Subkeys: Z1..Z52.
    // R1: Z1..Z6
    // ...
    // R8: Z43..Z48
    // R9 (Output): Z49..Z52
    
    // Dec Subkeys: DK1..DK52
    // R1: DK1..DK6 (Derived from Z49..Z52 and Z47..Z48)
    // DK1 = Z49^-1
    // DK2 = -Z50
    // DK3 = -Z51
    // DK4 = Z52^-1
    // DK5 = Z47
    // DK6 = Z46  <-- Note indices
    
    dec_subkeys[0] = mulInv(subkeys[48]); // Z49
    dec_subkeys[1] = addInv(subkeys[49]); // Z50
    dec_subkeys[2] = addInv(subkeys[50]); // Z51
    dec_subkeys[3] = mulInv(subkeys[51]); // Z52
    dec_subkeys[4] = subkeys[46];         // Z47
    dec_subkeys[5] = subkeys[47];         // Z48 (Wait, Z47 is subkeys[46], Z48 is subkeys[47])

    // Middle rounds (r=1 to 7 corresponding to Dec rounds 2 to 8)
    // Dec Round i (2..8) derived from Enc Round 9-i+1
    // We already did r=0 (Round 1).
    // Loop for r=1..7
    for (1..8) |r| {
        const dec_base = r * 6;
        const enc_round = 8 - r; // 7 down to 1
        const enc_base = enc_round * 6;
        
        dec_subkeys[dec_base + 0] = mulInv(subkeys[enc_base + 0]); // Z(enc_base+1)
        dec_subkeys[dec_base + 1] = addInv(subkeys[enc_base + 2]); // -Z(enc_base+3)
        dec_subkeys[dec_base + 2] = addInv(subkeys[enc_base + 1]); // -Z(enc_base+2)
        dec_subkeys[dec_base + 3] = mulInv(subkeys[enc_base + 3]); // Z(enc_base+4)^-1
        
        dec_subkeys[dec_base + 4] = subkeys[enc_base - 2];     // Z(prev_round_5) -> Z(enc_base-2)
        dec_subkeys[dec_base + 5] = subkeys[enc_base - 1];     // Z(prev_round_6) -> Z(enc_base-1)
    }
    
    // Final half-round (Dec Round 9) derived from Enc Round 1
    // Enc Round 1: Z1..Z6 (subkeys[0]..subkeys[5])
    // But we only need Z1..Z4
    dec_subkeys[48] = mulInv(subkeys[0]);
    dec_subkeys[49] = addInv(subkeys[1]);
    dec_subkeys[50] = addInv(subkeys[2]);
    dec_subkeys[51] = mulInv(subkeys[3]);
    
    return dec_subkeys;
}

pub fn processBlock(block: u64, subkeys: [52]u16) u64 {
    var x1: u16 = @intCast((block >> 48) & 0xFFFF);
    var x2: u16 = @intCast((block >> 32) & 0xFFFF);
    var x3: u16 = @intCast((block >> 16) & 0xFFFF);
    var x4: u16 = @intCast(block & 0xFFFF);

    for (0..8) |round| {
        const k = round * 6;
        
        // 1. Multiply X1 and the first subkey Z1.
        x1 = mul(x1, subkeys[k + 0]);
        // 2. Add X2 and the second subkey Z2.
        x2 = x2 +% subkeys[k + 1];
        // 3. Add X3 and the third subkey Z3.
        x3 = x3 +% subkeys[k + 2];
        // 4. Multiply X4 and the fourth subkey Z4.
        x4 = mul(x4, subkeys[k + 3]);
        
        // 5. Bitwise XOR the results of steps 1 and 3.
        var t0 = x1 ^ x3;
        // 6. Bitwise XOR the results of steps 2 and 4.
        var t1 = x2 ^ x4;
        
        // 7. Multiply the result of step 5 and the fifth subkey Z5.
        t0 = mul(t0, subkeys[k + 4]);
        
        // 8. Add the results of steps 6 and 7.
        t1 = t1 +% t0;
        
        // 9. Multiply the result of step 8 and the sixth subkey Z6.
        t1 = mul(t1, subkeys[k + 5]);
        
        // 10. Add the results of steps 7 and 9.
        t0 = t0 +% t1;
        
        // 11. XOR the results of steps 1 and 9.
        x1 = x1 ^ t1;
        // 12. XOR the results of steps 3 and 9.
        x3 = x3 ^ t1;
        // 13. XOR the results of steps 2 and 10.
        x2 = x2 ^ t0;
        // 14. XOR the results of steps 4 and 10.
        x4 = x4 ^ t0;
        
        // Swap X2 and X3 for next round (except last round)
        // Note: The structure often says "Swap output of 2 and 3". 
        // My x2 and x3 are updated variables.
        // Let's check standard description.
        // Output of round is (x1, x3, x2, x4) ?
        // Usually implementation does swap at the end of loop, but NOT at the end of last round.
        
        const temp = x2;
        x2 = x3;
        x3 = temp;
    }
    
    // Undo the last swap (or don't do it in the loop)
    const temp = x2;
    x2 = x3;
    x3 = temp;
    
    // Output transformation (Half round)
    x1 = mul(x1, subkeys[48]);
    x2 = x2 +% subkeys[49];
    x3 = x3 +% subkeys[50];
    x4 = mul(x4, subkeys[51]);
    
    return (@as(u64, x1) << 48) | (@as(u64, x2) << 32) | (@as(u64, x3) << 16) | @as(u64, x4);
}

pub fn keyToU128(key: []const u8) !u128 {
    if (key.len != 16) return error.InvalidKeyLength;
    var result: u128 = 0;
    for (key, 0..) |byte, i| {
        result |= @as(u128, byte) << @intCast((15 - i) * 8);
    }
    return result;
}
